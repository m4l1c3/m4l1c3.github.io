---
layout: post
title: Google Gruyere
---
#XSS

##File upload
For this I simply uploaded the following in an HTML file:

{% highlight html %}
<html><head<title></title></head><body><script>alert('hi')</script></body>
{% endhighlight %}

Then browsed to the URL provided

##Reflected XSS
This was as simple as appending the following to the site URL:

{% hightlight  html %}
<script>alert('hi')</script>
{% endhighlight %}

##Stored XSS
Here there are two places that come to mind immediately, snippets and the profile page.  There are quite a few ways to skin this cat, the one I was able to get working in multiple browsers was by using the onmouseover attribute of valid HTML elements to pop an alert, this was done using a snippet:

{% hightlight html %}
<a href="#" onmouseover="alert(1)">test</a>
{% endhighlight %}

##Stored XSS Via HTML Attributes
The only place I can think of to perform this other than a snippet which we already got exploited is in the profile page, it wasn't obvious to be intially, but the profile color input can be used to apply inline CSS to your name on the home page.  For this I ended up with the following:

{% highlight html %}
black' onmouseover='alert(1)' onfocus='alert(2)' onblur='alert(3)
{% endhighlight %}

This makes my user's name throw an alert on hover, then on the edit profile page is pops on focus and blur, one thing to note, this didn't initially fire because I was trying to follow normal HTML standards, after viewing page source rather than using browser debug tools I saw single quotes were used rather than normal double quotes.

##Stored XSS Via Ajax
This one took a lot of messing around, based on Google's provided hints, the refresh button was our target.  After tinkiner a lot I was able to come up with this:

{% highlight javascript %}
hey <span style=display:none>eval(" + (alert(1),"") + ")</span>hi
{% endhighlight %}

This works because when you hit refresh on home a JSON object containing the latest snippets from each user gets eval'd in JavaScript, it took me quite a while to get this because I kept thinking I would need valid JSON, however when using eval the JSON value just has to be parseable JavaScript.

##Reflected XSS Via Ajax
This is very similar to the previous reflected XSS attack mentioned previously, it just gets hit in a different way.  After reading and looking through the code samples Google provides I noticed that the feed page when supplied the uid query string parameter does an eval-ish processing on the page that takes a URL like this:

{% highlight html %}
feed.gtl?uid=<script>alert(1)</script>
{% endhighlight %}

Then renders like this in page source:
{% highlight javascript %}
_feed((
[
"<script>alert(1)</script>"
]
))
{% endhighlight %}



{
"private_snippet":
  "private"

,"cheddar":
  "Gruyere is the cheesiest application on the web."


,"bob":
  "all <span style=display:none>" + (alert(1),"") + "</span>your base"
,"brie":
  "Brie is the queen of the cheeses<span style=color:red>!!!</span>"
}

#Client-State manipulation

##Priviledge elevation
In watching requests go through Burp I noticed that user registration passes the query string parameter is_author=True, which made me wonder if there was an is_admin option to pass.  After that I was seeing my requests to update a user profile, this also included the is_author parameter.  So I just started trying to set is admin.  Initially it seemed like no attempts were working, after looking through Google's hints it turns out that you need to log out then log back in, this way the cookie that gets used to identify you includes the admin flag, which doesn't happen by just editing the cookie.  

The reason for this is that the cookie is structured as follows:

32400598|bob||author

The first integer value is a token that gets generated server side, this seems to be the reason I wasn't able to just modify the cookie directly to get elevated privilidges.  Upon logging out and back in the cookie looks more like this:

32400598|bob|admin|author

Now the profile page has all the admin options and the manage server link also shows up.

##Cookie manipulation
This actually ended up being a bit more difficult, the cookie that gets set to identify a given browser as being a given system user gets generated based on the login or signing up of a user.  After trying a lot of different options I broke down and looked at the hints from Google and ended up with:

brie|admin|author

As my username when registering, a side affect (or what appears to be one) is that this can circumvent logging in as well.  Upon clicking sign in I was authenticated as brie without actually logging in.

##CSRF
All of these items require browsing an HTML file locally while also authenticated with Gruyere

To complete the exercise of deleting someone's snippet:
{% highlight html %}
<html><head><title></title></head><body><img src="http://google-gruyere.appspot.com/458351305912/deletesnippet?index=0" /></body></html>
{% endhighlight %}

Then just for fun, I tested updating a user's profile using the same technique, which worked:
{% highlight html %}
<html><head><title></title></head><body><img src="http://google-gruyere.appspot.com/458351305912/saveprofile?action=update&uid=bob&name=bob&oldpw=&pw=&icon=buttfart&web_site=http%3A%2F%2Fgithub.com&color=black&private_snippet=privat" />
</body></html>
{% endhighlight %}

##XSSI
For this exercise I ended up with:
{% highlight html %}
<html><head><title></title></head><body>
<script>function _feed(s) {document.write('your private thing is: ' + s['private_snippet']);}</script><script src="http://google-gruyere.appspot.com/458351305912/feed.gtl"></script></body></html>
{% endhighlight %}

What this is doing is defining a function that matches how the JavaScript in feed.gtl gets called, and then outputting data stored outside of our local files boundaries, but because the executing script has Google's system/domain as its context it has access to the snipped data where our _feed(s) function  would have never had access.

#Path Traversal

##Information disclosure via path traversal
This ended up being really simple, but the browser was correcting the URL so it didn't work initially, my ../secret.txt needed to be ..%2Fsecret.txt, updating the encoding made things work.

##Data tampering via path traversal


#Denial of Service

##DoS - Quit the server

##DoS - Overloading the server

#Code Execution